#include <fstream>
#include<istream>
#include<iostream>
#include<cstring>
#include<time.h>
// include headers that implement a archive in simple text format
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/serialization/unordered_map.hpp>
#include<unordered_map>

#include<string>
// include headers that implement a archive in simple text format
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/serialization/unordered_map.hpp>
#include<unordered_map>

#define MAX 1024*1024

struct node
{
	int value;
	
	node(){
	}
	node(int pat){
		value = pat;
	}

	node(node& obj){
		this->value = obj.value;
	}

	template<class Archive>
	void serialize(Archive &ar, const unsigned int version)
	{
		ar & value;
	}
};

typedef std::unordered_map<int, node> MyMap;
void save(const MyMap &a, std::string name);
void load(MyMap &retrieved_map,std::string name);


class HashTable
{	
public:
	MyMap *map;
	
	HashTable(){
		map = new MyMap();
	};
	HashTable(HashTable &h){
		this->map = h.map;
	}

	void DeleteMap()
	{
		if (map)
		{
			delete map;
		}
		
		map = NULL;
	};
	~HashTable(){ if (map) delete map; };
	
	template<class Archive>
	void serialize(Archive &ar, const unsigned int version)
	{	
		ar & BOOST_SERIALIZATION_NVP(map);
	}
	
	void update(int lba,int transfer_length, int value){
		node n(value);
		for (int i = 0; i < transfer_length; i++)
		{
			map->insert({ lba + i, n });
		}
	}
};

class TableGroup{
public:
	int no_hashmaps;
	int lbas_per_hashmap;
	HashTable *table;
	int current_loaded = -1;
	
	TableGroup(){};
	
	TableGroup(int size_in_gb, int size_per_hashmap){
		no_hashmaps = size_in_gb / size_per_hashmap;
	
		table = new HashTable[no_hashmaps];
		lbas_per_hashmap = size_per_hashmap * 1024 * 1024 ;
	
		
		//for (int i = 0; i < no_hashmaps; i++){
			//std::string name = "hash" + std::to_string(i);
			//save(*(table[i].map),name);
		//}
	}

	int findTableIndex(int lba){
		return int(lba / lbas_per_hashmap);
	}
	int getEndingLba(int bucket){
		//+1 as index is 0 based.
		return lbas_per_hashmap*(bucket+1)-1;
	}
	void deleteTable(int index){
			table[index].DeleteMap();	
	}
	void updateTable(int lba, int transfer_length,int value){
		int index = findTableIndex(lba);
		std::cout << "Index" << index <<std::endl;
		int index_end = findTableIndex(lba + transfer_length);
		std::cout <<"End index "<< index_end<<std::endl;
			//LBA Range lies in the single hash table		
			if (index == index_end){
				
					std::string name = "hash" + std::to_string(index);
					//Load the required table , and save the currently loaded.
					if (current_loaded != index){

						if (current_loaded != -1){
							save(*table[current_loaded].map, name);
							std::cout << "Saving to file ..." << current_loaded << std::endl;
							//Delete this table from Memory	
							deleteTable(current_loaded);
							std::cout << "Deleting... " << current_loaded << std::endl;
						}
						std::cout << "Loading from file " << index << std::endl;
						load(*table[index].map, name);
						current_loaded = index;
					}
					//Update the newly loaded table.
					std::cout << "Updating map..." << index<<std::endl;
					table[index].update(lba, transfer_length, value);
					//Remove Save from here.It should be called only before deleting it.
					//save(*table[index].map, name);
					return;
				}
			//LBA Range lies in two hashtables
			else if (index_end == index + 1){
						int end = getEndingLba(index);
						std::cout << "END" << end<<std::endl;
				if (current_loaded == index + 1){
					std::cout << "updating for ranges" << index << std::endl;
					updateTable(end + 1, transfer_length-end, value);
					updateTable(lba,end - lba + 1, value);
				}
				else{
					updateTable(lba, end - lba + 1, value);
					updateTable(end + 1, transfer_length - end,value);
					std::cout << "First Range" << lba << "," << lba+end - lba + 1 << "\n";
					std::cout << "Second Range " << end + 1 << " , " << lba + transfer_length;
				}
			}
		}
};


void save(const MyMap &a,std::string name){
	std::ofstream ofs(name);
	{
		boost::archive::text_oarchive oa(ofs);
		// write class instance to archive
		oa << a;
		// archive and stream closed when destructors are called
	}
}

void load(MyMap &retrieved_map,std::string name){
	// create and open an archive for input
	std::ifstream ifs(name);
	boost::archive::text_iarchive ia(ifs);
	// read class state from archive
	ia >> retrieved_map;
	// archive and stream closed when destructors are called
}


int main(){

	std::clock_t t;
	t = clock();
	TableGroup T(5, 1);
	/*
T.updateTable(0,MAX/2,50);
T.updateTable(MAX+5,MAX/2, 62);
T.updateTable(2*MAX+5,MAX/2, 73);
T.updateTable(4 * MAX + 5, MAX / 2, 73);
*/

T.updateTable(1024 * 1024 - 8000, 16000, 50);
//T.updateTable(1024 * 1024 - 8000, 16000, 50);
//T.updateTable(1024*1024-8000,16000, 50);
//T.updateTable(1024 * 1024,10000, 50);
t = clock() - t;
std::cout << "It took " << float(t)/1000;
//T.updateTable(1024*1024*1-3000,7000,32);
//T.updateTable(1024 * 1024 * 3 + 5,200000,56);

getchar();
return 0;
}
